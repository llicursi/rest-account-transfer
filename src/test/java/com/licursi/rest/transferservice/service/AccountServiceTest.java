package com.licursi.rest.transferservice.service;

import com.licursi.rest.transferservice.AccountBuilder;
import com.licursi.rest.transferservice.exceptions.BalanceConstraintViolationException;
import com.licursi.rest.transferservice.exceptions.NegativeConstraintViolationException;
import com.licursi.rest.transferservice.model.Account;
import com.licursi.rest.transferservice.repository.AccountRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.context.junit4.SpringRunner;

import java.math.BigDecimal;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;


@RunWith(SpringRunner.class)
public class AccountServiceTest {

    @Mock
    private AccountRepository accountRepository;

    @InjectMocks
    private AccountService accountService;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void whenSave_thenReturnAutoGeneratedId() throws BalanceConstraintViolationException {
        final Account account = AccountBuilder.createGeneric().noId().build();
        assertThat(account.getId()).isNull();

        when(accountRepository.save(any(Account.class))).thenReturn(AccountBuilder.createGeneric().build());

        Account accountSaved = accountService.save(account);
        assertThat(accountSaved.getId()).isNotNull();

        verify(accountRepository, times(1)).save(account);
        verifyNoMoreInteractions(accountRepository);
    }


    @Test(expected = BalanceConstraintViolationException.class)
    public void whenSaveNegativeBalance_throwException() throws BalanceConstraintViolationException {
        Account account = AccountBuilder.createGeneric("Sansa Stark").noId().balance(new BigDecimal("-1000")).build();
        accountService.save(account);

        verifyZeroInteractions(accountRepository);
    }


    @Test(expected = NegativeConstraintViolationException.class)
    public void whenDepositNegativeAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.deposit(account, new BigDecimal(-100));

        verifyZeroInteractions(accountRepository);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void whenDepositeZero_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.deposit(account, new BigDecimal(0));

        verifyZeroInteractions(accountRepository);
    }

    @Test
    public void whenDeposit100_thenAccountRiseBy100() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        int initialValue = 100;
        int finalValue = 200;
        Account account = AccountBuilder.createGeneric().balance(new BigDecimal(initialValue)).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, new BigDecimal(100));

        assertThat(account.getBalance()).isEqualTo(new BigDecimal(finalValue));
    }


    @Test
    public void whenDepositFloatingValue_thenAccountRiseByFloatingValue() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.33");
        BigDecimal raiseByValue = new BigDecimal("7.33");
        BigDecimal finalValue = new BigDecimal("17.66");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, raiseByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test
    public void whenDepositHugeValue_thenAccountRiseByHugeValue() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.66");
        BigDecimal raiseByValue = new BigDecimal("999999999989.33");
        BigDecimal finalValue = new BigDecimal("999999999999.99");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, raiseByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void whenWithdrawNegativeAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.withdraw(account, new BigDecimal(-100));

        verifyZeroInteractions(accountRepository);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void whenWithdrawZero_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.withdraw(account, new BigDecimal(0));

        verifyZeroInteractions(accountRepository);
    }

    @Test
    public void whenWithdraw100_thenBalanceReduceBy100() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        int initialValue = 100;
        int finalValue = 0;
        Account account = AccountBuilder.createGeneric().balance(new BigDecimal(initialValue)).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);
        accountService.withdraw(account, new BigDecimal(100));

        assertThat(account.getBalance()).isEqualTo(new BigDecimal(finalValue));
    }


    @Test
    public void whenWithdrawFloatingValue_thenBalanceReduceByFloatingValueKeepingPrecision() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.00");
        BigDecimal reducedByValue = new BigDecimal("9.99");
        BigDecimal finalValue = new BigDecimal("00.01");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test
    public void whenWithdrawHugeValue_thenBalanceReduceByHugeValueKeepingPrecision() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal finalValue = new BigDecimal("10.66");
        BigDecimal reducedByValue = new BigDecimal("999999999989.33");
        BigDecimal initialValue = new BigDecimal("999999999999.99");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test(expected = BalanceConstraintViolationException.class)
    public void whenWithdrawMoreThanAvailable_throwError() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal reducedByValue = new BigDecimal("999999999989.33");
        BigDecimal initialValue = new BigDecimal("10");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(initialValue);
    }
}