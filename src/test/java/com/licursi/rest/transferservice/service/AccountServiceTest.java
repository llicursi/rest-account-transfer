package com.licursi.rest.transferservice.service;

import com.licursi.rest.transferservice.AccountBuilder;
import com.licursi.rest.transferservice.exceptions.AccountNotFoundException;
import com.licursi.rest.transferservice.exceptions.BalanceConstraintViolationException;
import com.licursi.rest.transferservice.exceptions.NegativeConstraintViolationException;
import com.licursi.rest.transferservice.model.Account;
import com.licursi.rest.transferservice.repository.AccountRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.context.junit4.SpringRunner;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;
import java.util.stream.StreamSupport;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;


@RunWith(SpringRunner.class)
public class AccountServiceTest {

    @Mock
    private AccountRepository accountRepository;

    @InjectMocks
    private AccountService accountService;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void givenFindById_whenValidAccount_thenAccountIsReturned() throws AccountNotFoundException {
        Account account = AccountBuilder.createGeneric()
                .id(1L)
                .name("Night King")
                .balance(new BigDecimal(100.00))
                .build();
        when(accountRepository.findById(1L)).thenReturn(
                Optional.of(account));

        Account accountFound = accountService.findById(1L);

        assertThat(accountFound.getId()).isEqualTo(account.getId());
        assertThat(accountFound.getName()).isEqualTo(account.getName());
        assertThat(accountFound.getBalance()).isEqualTo(account.getBalance());


        verify(accountRepository, times(1)).findById(any(Long.class));
        verifyNoMoreInteractions(accountRepository);
    }

    @Test(expected = AccountNotFoundException.class)
    public void givenFindById_whenInvalidValidAccount_throwError() throws AccountNotFoundException {

        when(accountRepository.findById(2L)).thenReturn(Optional.empty());
        accountService.findById(2L);

        assertThat(false).isFalse();

    }

    @Test()
    public void givenFindById_whenInvalidValidAccount_thenCatchException() {

        Long id = 2L;
        when(accountRepository.findById(id)).thenReturn(Optional.empty());
        try {
            accountService.findById(id);
            assertThat(false).isFalse();
        } catch (AccountNotFoundException a) {
            assertThat(a.getMessage()).contains("Can not find requested account");
            assertThat(a.getAccountId()).isEqualTo(id);
        }


        verify(accountRepository, times(1)).findById(any(Long.class));
        verifyNoMoreInteractions(accountRepository);
    }

    @Test()
    public void givenFindAll_whenExistsAccounts_thenReturnList() {

        when(accountRepository.findAll()).thenReturn(Arrays.asList(
                AccountBuilder.createGeneric().id(1L).build(),
                AccountBuilder.createGeneric().id(2L).build()
        ));
        Iterable<Account> all = accountService.findAll();

        assertThat(StreamSupport.stream(all.spliterator(), false).count()).isEqualTo(2);

        verify(accountRepository, times(1)).findAll();
        verifyNoMoreInteractions(accountRepository);
    }

    @Test()
    public void givenFindAll_whenEmpty_thenReturnEmptyList() {

        when(accountRepository.findAll()).thenReturn(new ArrayList<>());
        Iterable<Account> all = accountService.findAll();

        assertThat(StreamSupport.stream(all.spliterator(), false).count()).isEqualTo(0);

        verify(accountRepository, times(1)).findAll();
        verifyNoMoreInteractions(accountRepository);
    }

    @Test
    public void givenSave_whenValidAccount_thenReturnAutoGeneratedId() throws BalanceConstraintViolationException {
        final Account account = AccountBuilder.createGeneric().noId().build();
        assertThat(account.getId()).isNull();

        when(accountRepository.save(any(Account.class))).thenReturn(AccountBuilder.createGeneric().build());

        Account accountSaved = accountService.save(account);
        assertThat(accountSaved.getId()).isNotNull();

        verify(accountRepository, times(1)).save(account);
        verifyNoMoreInteractions(accountRepository);
    }


    @Test(expected = BalanceConstraintViolationException.class)
    public void givenSave_whenAccountNegativeBalance_throwException() throws BalanceConstraintViolationException {
        Account account = AccountBuilder.createGeneric("Sansa Stark").noId().balance(new BigDecimal("-1000")).build();
        accountService.save(account);

        verifyZeroInteractions(accountRepository);
    }


    @Test(expected = NegativeConstraintViolationException.class)
    public void givenDeposit_whenNegativeAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.deposit(account, new BigDecimal(-100));

        verifyZeroInteractions(accountRepository);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void givenDeposit_whenZeroAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.deposit(account, new BigDecimal(0));

        verifyZeroInteractions(accountRepository);
    }

    @Test
    public void givenDeposit_whenNaturalValue_thenAccountRiseBySameAmount() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        int initialValue = 100;
        int finalValue = 200;
        Account account = AccountBuilder.createGeneric().balance(new BigDecimal(initialValue)).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, new BigDecimal(100));

        assertThat(account.getBalance()).isEqualTo(new BigDecimal(finalValue));
    }


    @Test
    public void givenDeposit_whenFloatingValue_thenAccountRiseByFloatingValue() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.33");
        BigDecimal raiseByValue = new BigDecimal("7.33");
        BigDecimal finalValue = new BigDecimal("17.66");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, raiseByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test
    public void givenDeposit_whenHugeValue_thenAccountRiseByHugeValue() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.66");
        BigDecimal raiseByValue = new BigDecimal("999999999989.33");
        BigDecimal finalValue = new BigDecimal("999999999999.99");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.deposit(account, raiseByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void givenWithdraw_whenNegativeAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.withdraw(account, new BigDecimal(-100));

        verifyZeroInteractions(accountRepository);
    }

    @Test(expected = NegativeConstraintViolationException.class)
    public void givenWithdraw_whenZeroAmount_throwException() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        Account account = AccountBuilder.createGeneric().build();

        accountService.withdraw(account, new BigDecimal(0));

        verifyZeroInteractions(accountRepository);
    }

    @Test
    public void givenWithdraw_whenNaturalValue_thenBalanceReduceByNaturalValue() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        int initialValue = 100;
        int finalValue = 0;
        Account account = AccountBuilder.createGeneric().balance(new BigDecimal(initialValue)).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);
        accountService.withdraw(account, new BigDecimal(100));

        assertThat(account.getBalance()).isEqualTo(new BigDecimal(finalValue));
    }


    @Test
    public void givenWithdraw_whenFloatingValue_thenBalanceReduceByFloatingValueKeepingPrecision() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal initialValue = new BigDecimal("10.00");
        BigDecimal reducedByValue = new BigDecimal("9.99");
        BigDecimal finalValue = new BigDecimal("00.01");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test
    public void givenWithdraw_whenHugeValue_thenBalanceReduceByHugeValueKeepingPrecision() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal finalValue = new BigDecimal("10.66");
        BigDecimal reducedByValue = new BigDecimal("999999999989.33");
        BigDecimal initialValue = new BigDecimal("999999999999.99");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(finalValue);
    }

    @Test(expected = BalanceConstraintViolationException.class)
    public void givenWithdraw_whenMoreThanAvailable_throwError() throws BalanceConstraintViolationException, NegativeConstraintViolationException {
        BigDecimal reducedByValue = new BigDecimal("999999999989.33");
        BigDecimal initialValue = new BigDecimal("10");
        Account account = AccountBuilder.createGeneric().balance(initialValue).build();

        when(accountRepository.save(any(Account.class))).thenReturn(account);

        accountService.withdraw(account, reducedByValue);

        assertThat(account.getBalance()).isEqualTo(initialValue);
    }
}